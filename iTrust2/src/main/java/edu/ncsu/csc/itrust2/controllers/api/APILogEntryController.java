package edu.ncsu.csc.itrust2.controllers.api;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import edu.ncsu.csc.itrust2.models.persistent.LogEntry;
import edu.ncsu.csc.itrust2.models.persistent.User;
import edu.ncsu.csc.itrust2.utils.LoggerUtil;

/**
 * REST controller for interacting with Log Entry-related endpoints This will
 * have somewhat reduced functionality compared to the other controllers because
 * we don't want users to be able to delete logged events (_even_ if they are
 * Personnel/an admin)
 *
 * @author Kai Presler-Marshall
 *
 */
@RestController
@SuppressWarnings ( { "unchecked", "rawtypes" } )
public class APILogEntryController extends APIController {

    /**
     * Retrieves and returns a List of all LogEntries in the system
     *
     * @return list of log entries
     */
    @GetMapping ( BASE_PATH + "/logentries" )
    public List<LogEntry> getLogEntries () {
        final List<LogEntry> allLogs = LogEntry.getLogEntries();
        Collections.reverse( allLogs );
        return allLogs;
    }

    /**
     * Retrieves and returns a specific log entry specified by the id provided.
     *
     * @param id
     *            The id of the log entry, as generated by Hibernate and used as
     *            the primary key
     * @return response
     */
    @GetMapping ( BASE_PATH + "/logentries/{id}" )
    public ResponseEntity getEntry ( @PathVariable ( "id" ) final Long id ) {
        final LogEntry entry = LogEntry.getById( id );
        return null == entry
                ? new ResponseEntity( errorResponse( "No log entry found for id " + id ), HttpStatus.NOT_FOUND )
                : new ResponseEntity( entry, HttpStatus.OK );
    }

    /**
     * Gets the top ten LogEntries
     *
     * @param user
     *            id
     * @return the top 10 LogEntries
     */
    @GetMapping ( BASE_PATH + "/logentriesten/{id}" )
    public List<LogEntry> getLogEntriesSpan ( @PathVariable ( "id" ) final String user ) {
        return LoggerUtil.getTopForUser( user, 10 );
    }

    /**
     * Returns LogEntries between timeOne and timeTwo in a order that shows most
     * recent LogEntry first
     *
     * @param user
     *            id
     * @param timeOne
     *            start date
     * @param timeTwo
     *            end date
     * @return LogEntries between start date and end date
     */
    @GetMapping ( value = BASE_PATH + "/logEntriesSpan" )
    public List<LogEntry> getLogEntriesSpan ( final Calendar timeOne, final Calendar timeTwo ) {
        final User self = User.getByName( SecurityContextHolder.getContext().getAuthentication().getName() );
        if ( self == null ) {
            return null;
        }

        if ( timeOne.compareTo( timeTwo ) > 0 ) {// start data is after end date
            return null; // TODO throw exception?
        }
        final List<LogEntry> list = LogEntry.getAllForUser( self.getUsername() );
        list.sort( new Comparator<Object>() {
            @Override
            public int compare ( final Object arg0, final Object arg1 ) {
                return ( (LogEntry) arg0 ).getTime().compareTo( ( (LogEntry) arg1 ).getTime() );
            }
        } );

        // list is sorted
        final List<LogEntry> listBetweenDates = new ArrayList<LogEntry>();

        // binary search the start date and end date

        final int size = list.size();
        for ( int i = 0; i < size; i++ ) { // LogEntry is after start date
                                           // and before end date
            final LogEntry cur = list.get( i );
            if ( cur.getTime().compareTo( timeTwo ) <= 0 && cur.getTime().compareTo( timeOne ) >= 0 ) {
                listBetweenDates.add( cur );
            }
        }

        return listBetweenDates;
    }

    /**
     * Get all log entries for a specified user
     *
     * @return all logs for that user
     */
    @GetMapping ( BASE_PATH + "/logentriesuser" )
    public List<LogEntry> getLogEntriesUser () {
        final User self = User.getByName( SecurityContextHolder.getContext().getAuthentication().getName() );
        if ( self == null ) {
            return null;
        }
        final List<LogEntry> list = LogEntry.getAllForUser( self.getUsername() );
        list.sort( new Comparator<Object>() {
            @Override
            public int compare ( final Object arg0, final Object arg1 ) {
                return ( (LogEntry) arg1 ).getTime().compareTo( ( (LogEntry) arg0 ).getTime() );
            }
        } );

        // list is sorted
        final int size = list.size();
        if ( size <= 10 ) {
            return list;
        }
        else {
            return list.subList( 0, 10 );
        }
    }
}
